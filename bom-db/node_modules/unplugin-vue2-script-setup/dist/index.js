'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var unplugin$1 = require('unplugin');
var pluginutils = require('@rollup/pluginutils');
var MagicString = require('magic-string');
var reactivityTransform = require('@vue/reactivity-transform');
var htmlparser2 = require('htmlparser2');
var compilerCore = require('@vue/compiler-core');
var compilerDom = require('@vue/compiler-dom');
var shared = require('@vue/shared');
var babel = require('@babel/core');
var parser = require('@babel/parser');
var g = require('@babel/generator');
var utils = require('@antfu/utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var g__default = /*#__PURE__*/_interopDefaultLegacy(g);

function getIdentifierDeclarations(nodes, identifiers = new Set()) {
    for (let node of nodes) {
        if (node.type === 'ExportNamedDeclaration') {
            node = node.declaration;
            if (!node)
                continue;
        }
        if (node.type === 'ImportDeclaration') {
            for (const specifier of node.specifiers)
                identifiers.add(specifier.local.name);
        }
        else if (node.type === 'VariableDeclaration') {
            function handleVariableId(node) {
                if (node.type === 'Identifier') {
                    identifiers.add(node.name);
                }
                else if (node.type === 'ObjectPattern') {
                    for (const property of node.properties) {
                        if (property.type === 'ObjectProperty')
                            handleVariableId(property.value);
                        else if (property.type === 'RestElement' && property.argument.type === 'Identifier')
                            identifiers.add(property.argument.name);
                    }
                }
                else if (node.type === 'ArrayPattern') {
                    for (const element of node.elements) {
                        if ((element === null || element === void 0 ? void 0 : element.type) === 'Identifier')
                            identifiers.add(element.name);
                        else if ((element === null || element === void 0 ? void 0 : element.type) === 'RestElement' && element.argument.type === 'Identifier')
                            identifiers.add(element.argument.name);
                        else if ((element === null || element === void 0 ? void 0 : element.type) === 'ObjectPattern' || (element === null || element === void 0 ? void 0 : element.type) === 'ArrayPattern')
                            handleVariableId(element);
                    }
                }
            }
            for (const declarator of node.declarations)
                handleVariableId(declarator.id);
        }
        else if (node.type === 'FunctionDeclaration' || node.type === 'ClassDeclaration') {
            if (node.id)
                identifiers.add(node.id.name);
        }
        else if (node.type === 'TSEnumDeclaration') {
            if (node.id)
                identifiers.add(node.id.name);
        }
        // else {
        //   console.log(node)
        // }
    }
    return identifiers;
}
function getIdentifierUsages(node, identifiers = new Set()) {
    if (!node)
        return identifiers;
    if (node.type === 'BlockStatement') {
        node.body.forEach(child => getIdentifierUsages(child, identifiers));
    }
    else if (node.type === 'ExpressionStatement') {
        getIdentifierUsages(node.expression, identifiers);
    }
    else if (node.type === 'Identifier') {
        identifiers.add(node.name);
    }
    else if (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') {
        getIdentifierUsages(node.object, identifiers);
        if (node.computed)
            getIdentifierUsages(node.property, identifiers);
    }
    else if (node.type === 'CallExpression' || node.type === 'OptionalCallExpression') {
        getIdentifierUsages(node.callee, identifiers);
        node.arguments.forEach(arg => getIdentifierUsages(arg, identifiers));
    }
    else if (node.type === 'BinaryExpression' || node.type === 'LogicalExpression') {
        getIdentifierUsages(node.left, identifiers);
        getIdentifierUsages(node.right, identifiers);
    }
    else if (node.type === 'UnaryExpression') {
        getIdentifierUsages(node.argument, identifiers);
    }
    else if (node.type === 'ForOfStatement' || node.type === 'ForInStatement') {
        getIdentifierUsages(node.right, identifiers);
    }
    else if (node.type === 'ConditionalExpression') {
        getIdentifierUsages(node.test, identifiers);
        getIdentifierUsages(node.consequent, identifiers);
        getIdentifierUsages(node.alternate, identifiers);
    }
    else if (node.type === 'ObjectExpression') {
        node.properties.forEach((prop) => {
            if (prop.type === 'ObjectProperty') {
                if (prop.computed)
                    getIdentifierUsages(prop.key, identifiers);
                getIdentifierUsages(prop.value, identifiers);
            }
            else if (prop.type === 'SpreadElement') {
                getIdentifierUsages(prop, identifiers);
            }
        });
    }
    else if (node.type === 'ArrayExpression') {
        node.elements.forEach(element => getIdentifierUsages(element, identifiers));
    }
    else if (node.type === 'SpreadElement' || node.type === 'ReturnStatement') {
        getIdentifierUsages(node.argument, identifiers);
    }
    else if (node.type === 'NewExpression') {
        getIdentifierUsages(node.callee, identifiers);
        node.arguments.forEach(arg => getIdentifierUsages(arg, identifiers));
    }
    else if (node.type === 'ArrowFunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {
        getIdentifierUsages(node.body, identifiers);
    }
    else if (node.type === 'TemplateLiteral') {
        node.expressions.forEach(expr => getIdentifierUsages(expr, identifiers));
    }
    // else {
    //   console.log(node)
    // }
    return identifiers;
}

const t = (babel__namespace.default || babel__namespace).types;
const generate = (g__default["default"].default || g__default["default"]);

const pascalize = (str) => shared.capitalize(shared.camelize(str));
const isNotNil = (value) => value != null;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const exhaustiveCheckReturnUndefined = (param) => undefined;

var NodeTypes;
(function (NodeTypes) {
    NodeTypes.ROOT = 0, NodeTypes.ELEMENT = 1, NodeTypes.TEXT = 2, NodeTypes.COMMENT = 3, NodeTypes.SIMPLE_EXPRESSION = 4, NodeTypes.INTERPOLATION = 5, NodeTypes.ATTRIBUTE = 6, NodeTypes.DIRECTIVE = 7, NodeTypes.COMPOUND_EXPRESSION = 8, NodeTypes.IF = 9, NodeTypes.IF_BRANCH = 10, NodeTypes.FOR = 11, NodeTypes.TEXT_CALL = 12, NodeTypes.VNODE_CALL = 13, NodeTypes.JS_CALL_EXPRESSION = 14, NodeTypes.JS_OBJECT_EXPRESSION = 15, NodeTypes.JS_PROPERTY = 16, NodeTypes.JS_ARRAY_EXPRESSION = 17, NodeTypes.JS_FUNCTION_EXPRESSION = 18, NodeTypes.JS_CONDITIONAL_EXPRESSION = 19, NodeTypes.JS_CACHE_EXPRESSION = 20, NodeTypes.JS_BLOCK_STATEMENT = 21, NodeTypes.JS_TEMPLATE_LITERAL = 22, NodeTypes.JS_IF_STATEMENT = 23, NodeTypes.JS_ASSIGNMENT_EXPRESSION = 24, NodeTypes.JS_SEQUENCE_EXPRESSION = 25, NodeTypes.JS_RETURN_STATEMENT = 26;
})(NodeTypes || (NodeTypes = {}));
var ElementTypes;
(function (ElementTypes) {
    ElementTypes.ELEMENT = 0, ElementTypes.COMPONENT = 1, ElementTypes.SLOT = 2, ElementTypes.TEMPLATE = 3;
})(ElementTypes || (ElementTypes = {}));
const multilineCommentsRE = /\/\*\s(.|[\r\n])*?\*\//gm;
const singlelineCommentsRE = /\/\/\s.*/g;
const BUILD_IN_DIRECTIVES = new Set([
    'if',
    'else',
    'else-if',
    'for',
    'once',
    'model',
    'on',
    'bind',
    'slot',
    'slot-scope',
    'key',
    'ref',
    'text',
    'html',
    'show',
    'pre',
    'cloak',
    // 'el',
    // 'ref',
]);
function getComponents(node) {
    var _a;
    const current = node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.COMPONENT
        ? [node.tag]
        : node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT
            ? [node.tag]
            : [];
    const children = node.type === NodeTypes.IF
        ? node.branches
        : node.type === NodeTypes.ELEMENT
            || node.type === NodeTypes.IF_BRANCH
            || node.type === NodeTypes.FOR
            ? node.children
            : node.type === NodeTypes.TEXT
                || node.type === NodeTypes.COMMENT
                || node.type === NodeTypes.COMPOUND_EXPRESSION
                || node.type === NodeTypes.TEXT_CALL
                || node.type === NodeTypes.INTERPOLATION
                ? []
                : (_a = exhaustiveCheckReturnUndefined()) !== null && _a !== void 0 ? _a : [];
    return [...current, ...children.flatMap(getComponents)];
}
function getDirectiveNames(node) {
    if (node.type === NodeTypes.ELEMENT) {
        const directives = node.props.flatMap(x => x.type === NodeTypes.DIRECTIVE ? [x.name] : []);
        return [...directives, ...node.children.flatMap(getDirectiveNames)];
    }
    else if (node.type === NodeTypes.IF) {
        return node.branches.flatMap(getDirectiveNames);
    }
    else if (node.type === NodeTypes.IF_BRANCH || node.type === NodeTypes.FOR) {
        return node.children.flatMap(getDirectiveNames);
    }
    else if (node.type === NodeTypes.INTERPOLATION
        || node.type === NodeTypes.COMPOUND_EXPRESSION
        || node.type === NodeTypes.TEXT
        || node.type === NodeTypes.COMMENT
        || node.type === NodeTypes.TEXT_CALL) {
        return [];
    }
    else {
        return [];
    }
}
function getFreeVariablesForText(input) {
    const identifiers = new Set();
    const inputWithPrefix = input.trimStart()[0] === '{' ? `(${input})` : input;
    const nodes = parser.parse(inputWithPrefix).program.body;
    nodes.forEach(node => getIdentifierUsages(node, identifiers));
    return [...identifiers.values()];
}
function getFreeVariablesForPropsNode(node) {
    if (node.type === NodeTypes.DIRECTIVE) {
        const arg = node.arg === undefined ? [] : getFreeVariablesForNode(node.arg);
        const exp = node.exp === undefined ? [] : getFreeVariablesForNode(node.exp);
        return [...arg, ...exp];
    }
    return [];
}
function getFreeVariablesForNode(node) {
    var _a, _b, _c;
    if (node.type === NodeTypes.SIMPLE_EXPRESSION) {
        return node.isStatic ? [] : getFreeVariablesForText(node.content);
    }
    else if (node.type === NodeTypes.COMPOUND_EXPRESSION) {
        return node.children.flatMap(x => typeof x !== 'object' ? [] : getFreeVariablesForNode(x));
    }
    else if (node.type === NodeTypes.INTERPOLATION) {
        return getFreeVariablesForNode(node.content);
    }
    else if (node.type === NodeTypes.ELEMENT) {
        const children = node.children.flatMap(getFreeVariablesForNode);
        const directiveProps = node.props
            .flatMap(x => x.type === NodeTypes.DIRECTIVE ? [x] : []);
        const attributeProps = node.props
            .flatMap(x => x.type === NodeTypes.ATTRIBUTE ? [x] : []);
        const refNode = attributeProps.find(node => node.name === 'ref' && node.value !== undefined);
        const refIdentifier = (_a = refNode === null || refNode === void 0 ? void 0 : refNode.value) === null || _a === void 0 ? void 0 : _a.content;
        const vSlotNode = directiveProps.find(node => node.name === 'slot');
        const vSlotArgIdentifiers = (vSlotNode === null || vSlotNode === void 0 ? void 0 : vSlotNode.arg) === undefined ? [] : getFreeVariablesForNode(vSlotNode.arg);
        // TODO: Variable shadowing
        const vSlotExpVariableShadowingIdentifiers = [];
        const vForNode = directiveProps.find(node => node.name === 'for');
        const vForIdentifiers = ((_b = vForNode === null || vForNode === void 0 ? void 0 : vForNode.exp) === null || _b === void 0 ? void 0 : _b.type) === NodeTypes.SIMPLE_EXPRESSION ? getFreeVariablesForText(vForNode.exp.content.replace(/^.*\s(?:in|of)\s/, '')) : [];
        // TODO: Variable shadowing
        const vForExpVariableShadowingIdentifiers = [];
        const props = directiveProps
            .filter(({ name }) => name !== 'slot' && name !== 'for')
            .flatMap(getFreeVariablesForPropsNode);
        const shadowingIdentifiers = new Set([...vSlotExpVariableShadowingIdentifiers, ...vForExpVariableShadowingIdentifiers]);
        return [
            ...vSlotArgIdentifiers,
            refIdentifier,
            ...vForIdentifiers,
            ...([...children, ...props]).filter(x => !shadowingIdentifiers.has(x)),
        ].filter(isNotNil);
    }
    else if (node.type === NodeTypes.FOR) {
        return [node.source, ...node.children].flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.IF) {
        return ((_c = node.branches) !== null && _c !== void 0 ? _c : []).flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.IF_BRANCH) {
        return [node.condition, ...node.children]
            .filter(isNotNil)
            .flatMap(getFreeVariablesForNode);
    }
    else if (node.type === NodeTypes.TEXT || node.type === NodeTypes.COMMENT || node.type === NodeTypes.TEXT_CALL) {
        return [];
    }
    else {
        return [];
    }
}
function findReferencesForSFC(code) {
    var _a, _b, _c;
    const rootNode = compilerCore.baseParse(code, compilerDom.parserOptions);
    const templateChildNodes = rootNode.children.flatMap(node => node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.ELEMENT
        ? [node]
        : []);
    const templateNode = templateChildNodes.find(({ tag }) => tag === 'template');
    const components = (_a = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getComponents)) !== null && _a !== void 0 ? _a : [];
    const directives = (_b = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getDirectiveNames)) !== null && _b !== void 0 ? _b : [];
    const identifiers = (_c = templateNode === null || templateNode === void 0 ? void 0 : templateNode.children.flatMap(getFreeVariablesForNode)) !== null && _c !== void 0 ? _c : [];
    return {
        components,
        directives,
        identifiers,
    };
}
const htmlParserOptions = {
    xmlMode: true,
    lowerCaseTags: false,
    lowerCaseAttributeNames: false,
    recognizeSelfClosing: true,
};
function parseSFC(code, id, options) {
    var _a, _b, _c, _d;
    let templateLevel = 0;
    let inScriptSetup = false;
    let inScript = false;
    const striped = code
        .replace(multilineCommentsRE, r => ' '.repeat(r.length))
        .replace(singlelineCommentsRE, r => ' '.repeat(r.length));
    const scriptSetup = {
        start: 0,
        end: 0,
        contentStart: 0,
        contentEnd: 0,
        content: '',
        attrs: {},
        found: false,
        ast: undefined,
    };
    const script = {
        start: 0,
        end: 0,
        contentStart: 0,
        contentEnd: 0,
        content: '',
        attrs: {},
        found: false,
        ast: undefined,
    };
    let templateStart;
    let templateEnd;
    let templateLang = 'html';
    const parser$1 = new htmlparser2.Parser({
        onopentag(name, attributes) {
            if (!name)
                return;
            if (name === 'template') {
                if (templateLevel === 0) {
                    templateStart = parser$1.endIndex + 1;
                    if (attributes.lang === 'pug')
                        templateLang = 'pug';
                }
                templateLevel += 1;
            }
            if (name === 'script') {
                if ('setup' in attributes) {
                    scriptSetup.start = parser$1.startIndex;
                    scriptSetup.contentStart = parser$1.endIndex + 1;
                    scriptSetup.attrs = attributes;
                    scriptSetup.found = true;
                    inScriptSetup = true;
                }
                else {
                    script.start = parser$1.startIndex;
                    script.contentStart = parser$1.endIndex + 1;
                    script.attrs = attributes;
                    script.found = true;
                    inScript = true;
                }
            }
        },
        onclosetag(name) {
            if (name === 'template') {
                templateLevel -= 1;
                if (templateLevel === 0 && templateStart != null)
                    templateEnd = parser$1.startIndex;
            }
            if (inScriptSetup && name === 'script') {
                scriptSetup.end = parser$1.endIndex + 1;
                scriptSetup.contentEnd = parser$1.startIndex;
                scriptSetup.content = code.slice(scriptSetup.contentStart, scriptSetup.contentEnd);
                inScriptSetup = false;
            }
            if (inScript && name === 'script') {
                script.end = parser$1.endIndex + 1;
                script.contentEnd = parser$1.startIndex;
                script.content = code.slice(script.contentStart, script.contentEnd);
                inScript = false;
            }
        },
    }, htmlParserOptions);
    parser$1.write(striped);
    parser$1.end();
    if (script.found
        && scriptSetup.found
        && scriptSetup.attrs.lang !== script.attrs.lang) {
        throw new SyntaxError('<script setup> language must be the same as <script>');
    }
    const parserOptions = {
        sourceType: 'module',
        plugins: [],
    };
    const lang = scriptSetup.attrs.lang || script.attrs.lang || 'js';
    if (lang === 'ts')
        parserOptions.plugins.push('typescript');
    else if (lang === 'jsx')
        parserOptions.plugins.push('jsx');
    else if (lang === 'tsx')
        parserOptions.plugins.push('typescript', 'jsx');
    else if (lang !== 'js')
        throw new SyntaxError(`Unsupported script language: ${lang}`);
    scriptSetup.ast = parser.parse(scriptSetup.content, parserOptions).program;
    script.ast = parser.parse(script.content || '', parserOptions).program;
    scriptSetup.ast
        = ((_b = (_a = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _a === void 0 ? void 0 : _a.scriptSetup) === null || _b === void 0 ? void 0 : _b.call(_a, scriptSetup.ast)) || scriptSetup.ast;
    script.ast = ((_d = (_c = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _c === void 0 ? void 0 : _c.script) === null || _d === void 0 ? void 0 : _d.call(_c, script.ast)) || script.ast;
    const codeOfTemplate = (() => {
        if (templateStart == null || templateEnd == null)
            return undefined;
        const templateCode = code.slice(templateStart, templateEnd);
        const html = templateLang === 'html'
            ? templateCode
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            : require('pug').compile(templateCode, { filename: id })();
        return `<template>\n${html}\n</template>`;
    })();
    const a = codeOfTemplate ? findReferencesForSFC(codeOfTemplate) : undefined;
    return {
        id,
        template: {
            components: new Set(a === null || a === void 0 ? void 0 : a.components.map(pascalize)),
            directives: new Set(a === null || a === void 0 ? void 0 : a.directives.filter(x => !BUILD_IN_DIRECTIVES.has(x)).map(shared.camelize)),
            identifiers: new Set(a === null || a === void 0 ? void 0 : a.identifiers),
        },
        scriptSetup,
        script,
        parserOptions,
        extraDeclarations: [],
    };
}

// modified from https://github.com/vuejs/vue-next/blob/main/packages/compiler-sfc/src/compileScript.ts
// Special compiler macros
const DEFINE_PROPS = 'defineProps';
const DEFINE_EMITS = 'defineEmits';
const DEFINE_EXPOSE = 'defineExpose';
const WITH_DEFAULTS = 'withDefaults';
function applyMacros(nodes) {
    let hasDefinePropsCall = false;
    let hasDefineEmitCall = false;
    let propsRuntimeDecl;
    let propsRuntimeDefaults;
    let propsTypeDecl;
    let propsTypeDeclRaw;
    let emitsRuntimeDecl;
    let emitsTypeDecl;
    let emitsTypeDeclRaw;
    let exposeDecl;
    // props/emits declared via types
    const typeDeclaredProps = {};
    // record declared types for runtime props type generation
    const declaredTypes = {};
    function error(msg, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    node) {
        throw new Error(msg);
    }
    function processDefineProps(node) {
        if (!isCallOf(node, DEFINE_PROPS))
            return false;
        if (hasDefinePropsCall)
            error(`duplicate ${DEFINE_PROPS}() call`);
        hasDefinePropsCall = true;
        propsRuntimeDecl = node.arguments[0];
        // call has type parameters - infer runtime types from it
        if (node.typeParameters) {
            if (propsRuntimeDecl) {
                error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments `
                    + 'at the same time. Use one or the other.');
            }
            propsTypeDeclRaw = node.typeParameters.params[0];
            propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, node => node.type === 'TSTypeLiteral');
            if (!propsTypeDecl) {
                error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, `
                    + 'or a reference to an interface or literal type.');
            }
        }
        return true;
    }
    function processWithDefaults(node) {
        if (!isCallOf(node, WITH_DEFAULTS))
            return false;
        if (processDefineProps(node.arguments[0])) {
            if (propsRuntimeDecl) {
                error(`${WITH_DEFAULTS} can only be used with type-based `
                    + `${DEFINE_PROPS} declaration.`);
            }
            propsRuntimeDefaults = node.arguments[1];
        }
        else {
            error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
        }
        return true;
    }
    function processDefineEmits(node) {
        if (!isCallOf(node, DEFINE_EMITS))
            return false;
        if (hasDefineEmitCall)
            error(`duplicate ${DEFINE_EMITS}() call`);
        hasDefineEmitCall = true;
        emitsRuntimeDecl = node.arguments[0];
        if (node.typeParameters) {
            if (emitsRuntimeDecl) {
                error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments `
                    + 'at the same time. Use one or the other.');
            }
            emitsTypeDeclRaw = node.typeParameters.params[0];
            emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, node => node.type === 'TSFunctionType' || node.type === 'TSTypeLiteral');
            if (!emitsTypeDecl) {
                error(`type argument passed to ${DEFINE_EMITS}() must be a function type, `
                    + 'a literal type with call signatures, or a reference to the above types.');
            }
        }
        return true;
    }
    function resolveQualifiedType(node, qualifier) {
        if (qualifier(node))
            return node;
        if (node.type === 'TSTypeReference'
            && node.typeName.type === 'Identifier') {
            const refName = node.typeName.name;
            const isQualifiedType = (node) => {
                if (node.type === 'TSInterfaceDeclaration'
                    && node.id.name === refName)
                    return node.body;
                else if (node.type === 'TSTypeAliasDeclaration'
                    && node.id.name === refName
                    && qualifier(node.typeAnnotation))
                    return node.typeAnnotation;
                else if (node.type === 'ExportNamedDeclaration' && node.declaration)
                    return isQualifiedType(node.declaration);
            };
            for (const node of nodes) {
                const qualified = isQualifiedType(node);
                if (qualified)
                    return qualified;
            }
        }
    }
    function processDefineExpose(node) {
        if (!isCallOf(node, DEFINE_EXPOSE))
            return false;
        if (exposeDecl)
            error(`duplicate ${DEFINE_EXPOSE}() call`);
        if (node.arguments.length !== 1)
            error(`${DEFINE_EXPOSE}() requires one argument`);
        exposeDecl = node.arguments[0];
        return true;
    }
    function genRuntimeProps(props) {
        const keys = Object.keys(props);
        if (!keys.length)
            return undefined;
        // check defaults. If the default object is an object literal with only
        // static properties, we can directly generate more optimzied default
        // decalrations. Otherwise we will have to fallback to runtime merging.
        const hasStaticDefaults = propsRuntimeDefaults
            && propsRuntimeDefaults.type === 'ObjectExpression'
            && propsRuntimeDefaults.properties.every(node => node.type === 'ObjectProperty' && !node.computed);
        return t.objectExpression(Object.entries(props).map(([key, value]) => {
            const prop = hasStaticDefaults
                ? propsRuntimeDefaults.properties.find((node) => node.key.name === key)
                : undefined;
            if (prop)
                value.required = false;
            const entries = Object.entries(value).map(([key, value]) => key === 'type'
                ? t.objectProperty(t.identifier(key), typeof value === 'string' ? t.identifier(value) : t.arrayExpression(value.map((i) => t.identifier(i))))
                : t.objectProperty(t.identifier(key), parser.parseExpression(JSON.stringify(value))));
            if (prop)
                entries.push(t.objectProperty(t.identifier('default'), prop.value));
            return t.objectProperty(t.identifier(key), t.objectExpression(entries));
        }));
    }
    function getProps() {
        if (propsRuntimeDecl)
            return propsRuntimeDecl;
        if (propsTypeDecl) {
            extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
            return genRuntimeProps(typeDeclaredProps);
        }
    }
    function throwIfAwait(node) {
        if (node.type === 'AwaitExpression')
            error('top-level await is not supported in Vue 2');
    }
    nodes = nodes
        .map((raw) => {
        let node = raw;
        if (raw.type === 'ExpressionStatement')
            node = raw.expression;
        if (node.type === 'VariableDeclaration' && !node.declare) {
            const total = node.declarations.length;
            for (let i = 0; i < total; i++) {
                const decl = node.declarations[i];
                if (decl.init) {
                    if (processDefineEmits(decl.init))
                        decl.init = t.memberExpression(t.identifier('__ctx'), t.identifier('emit'));
                    else if (processDefineProps(decl.init) || processWithDefaults(decl.init))
                        decl.init = t.identifier('__props');
                    else
                        throwIfAwait(decl.init);
                }
            }
        }
        if (processWithDefaults(node) || processDefineEmits(node) || processDefineProps(node) || processDefineExpose(node))
            return null;
        throwIfAwait(node);
        return raw;
    })
        .filter(Boolean);
    return {
        nodes,
        props: getProps(),
        expose: exposeDecl,
    };
}
function isCallOf(node, test) {
    return !!(node
        && node.type === 'CallExpression'
        && node.callee.type === 'Identifier'
        && (typeof test === 'string'
            ? node.callee.name === test
            : test(node.callee.name)));
}
function extractRuntimeProps(node, props, declaredTypes) {
    const members = node.type === 'TSTypeLiteral' ? node.members : node.body;
    for (const m of members) {
        if ((m.type === 'TSPropertySignature' || m.type === 'TSMethodSignature')
            && m.key.type === 'Identifier') {
            let type;
            if (m.type === 'TSMethodSignature') {
                type = ['Function'];
            }
            else if (m.typeAnnotation) {
                type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
            }
            props[m.key.name] = {
                key: m.key.name,
                required: !m.optional,
                type: (type === null || type === void 0 ? void 0 : type.length) === 1 ? type[0] : type || 'null',
            };
        }
    }
}
function inferRuntimeType(node, declaredTypes) {
    switch (node.type) {
        case 'TSStringKeyword':
            return ['String'];
        case 'TSNumberKeyword':
            return ['Number'];
        case 'TSBooleanKeyword':
            return ['Boolean'];
        case 'TSObjectKeyword':
            return ['Object'];
        case 'TSTypeLiteral':
            // TODO (nice to have) generate runtime property validation
            return ['Object'];
        case 'TSFunctionType':
            return ['Function'];
        case 'TSArrayType':
        case 'TSTupleType':
            // TODO (nice to have) generate runtime element type/length checks
            return ['Array'];
        case 'TSLiteralType':
            switch (node.literal.type) {
                case 'StringLiteral':
                    return ['String'];
                case 'BooleanLiteral':
                    return ['Boolean'];
                case 'NumericLiteral':
                case 'BigIntLiteral':
                    return ['Number'];
                default:
                    return ['null'];
            }
        case 'TSTypeReference':
            if (node.typeName.type === 'Identifier') {
                if (declaredTypes[node.typeName.name])
                    return declaredTypes[node.typeName.name];
                switch (node.typeName.name) {
                    case 'Array':
                    case 'Function':
                    case 'Object':
                    case 'Set':
                    case 'Map':
                    case 'WeakSet':
                    case 'WeakMap':
                        return [node.typeName.name];
                    case 'Record':
                    case 'Partial':
                    case 'Readonly':
                    case 'Pick':
                    case 'Omit':
                    case 'Exclude':
                    case 'Extract':
                    case 'Required':
                    case 'InstanceType':
                        return ['Object'];
                }
            }
            return ['null'];
        case 'TSParenthesizedType':
            return inferRuntimeType(node.typeAnnotation, declaredTypes);
        case 'TSUnionType':
            return [
                ...new Set([].concat(...node.types.map(t => inferRuntimeType(t, declaredTypes)))),
            ];
        case 'TSIntersectionType':
            return ['Object'];
        default:
            return ['null']; // no runtime check
    }
}

function isAsyncImport(node) {
    var _a, _b;
    if (node.type === 'VariableDeclaration') {
        const declaration = node.declarations[0];
        return ((_b = (_a = declaration === null || declaration === void 0 ? void 0 : declaration.init) === null || _a === void 0 ? void 0 : _a.callee) === null || _b === void 0 ? void 0 : _b.name) === 'defineAsyncComponent';
    }
    return false;
}
function transformScriptSetup(sfc, options) {
    var _a, _b;
    const { scriptSetup, script, template } = sfc;
    const { nodes: body, props, expose } = applyMacros(scriptSetup.ast.body);
    const [hoisted, setupBody] = utils.partition(body, n => isAsyncImport(n)
        || n.type === 'ImportDeclaration'
        || n.type === 'ExportNamedDeclaration'
        || n.type.startsWith('TS'));
    // get all identifiers in `<script setup>`
    const declarations = new Set();
    getIdentifierDeclarations(hoisted, declarations);
    getIdentifierDeclarations(setupBody, declarations);
    const declarationArray = Array.from(declarations).filter(isNotNil);
    // filter out identifiers that are used in `<template>`
    const returns = declarationArray
        .filter(i => template.identifiers.has(i))
        .map((i) => {
        const id = t.identifier(i);
        return t.objectProperty(id, id, false, true);
    });
    const components = Array.from(template.components).map(component => {
        var _a;
        return (_a = declarationArray.find(declare => declare === component)) !== null && _a !== void 0 ? _a : declarationArray.find(declare => pascalize(declare) === component);
    }).filter(isNotNil);
    const directiveDeclaration = Array.from(template.directives).map((directive) => {
        const identifier = declarationArray.find(declaration => declaration === `v${shared.capitalize(directive)}`);
        if (identifier === undefined)
            return undefined;
        return { identifier, directive };
    }).filter(isNotNil);
    // append `<script setup>` imports to `<script>`
    const __sfc = t.identifier('__sfc_main');
    let hasBody = false;
    const bodyNodes = script.ast.body.map((node) => {
        // replace `export default` with a temproray variable
        // `const __sfc_main = { ... }`
        if (node.type === 'ExportDefaultDeclaration') {
            hasBody = true;
            return t.variableDeclaration('const', [
                t.variableDeclarator(__sfc, node.declaration),
            ]);
        }
        return node;
    });
    let ast = t.program([
        ...sfc.extraDeclarations,
        ...hoisted,
        ...bodyNodes,
    ]);
    // inject `const __sfc_main = {}` if `<script>` has default export
    if (!hasBody) {
        ast.body.push(t.variableDeclaration('const', [
            t.variableDeclarator(__sfc, t.objectExpression([])),
        ]));
    }
    // inject props function
    // `__sfc_main.props = { ... }`
    if (props) {
        hasBody = true;
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('props')), props)));
    }
    // inject setup function
    // `__sfc_main.setup = () => {}`
    if (body.length) {
        hasBody = true;
        const returnExpr = expose
            ? t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [t.objectExpression(returns), expose])
            : t.objectExpression(returns);
        const returnStatement = t.returnStatement(returnExpr);
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('setup')), t.arrowFunctionExpression([
            t.identifier('__props'),
            t.identifier('__ctx'),
        ], t.blockStatement([
            ...setupBody,
            returnStatement,
        ])))));
    }
    // inject components
    // `__sfc_main.components = Object.assign({ ... }, __sfc_main.components)`
    if (components.length) {
        hasBody = true;
        const componentsObject = t.objectExpression(components.map((i) => {
            const id = t.identifier(i);
            return t.objectProperty(id, id, false, true);
        }));
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('components')), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [
            componentsObject,
            t.memberExpression(__sfc, t.identifier('components')),
        ]))));
    }
    // inject directives
    // `__sfc_main.directives = Object.assign({ ... }, __sfc_main.directives)`
    if (directiveDeclaration.length) {
        hasBody = true;
        const directivesObject = t.objectExpression(directiveDeclaration.map(({ directive, identifier }) => (t.objectProperty(t.identifier(directive), t.identifier(identifier), false, false))));
        ast.body.push(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(__sfc, t.identifier('directives')), t.callExpression(t.memberExpression(t.identifier('Object'), t.identifier('assign')), [
            directivesObject,
            t.memberExpression(__sfc, t.identifier('directives')),
        ]))));
    }
    if (!hasBody && !(options === null || options === void 0 ? void 0 : options.astTransforms)) {
        return {
            ast: null,
            code: '',
        };
    }
    // re-export
    // `export default __sfc_main`
    ast.body.push(t.exportDefaultDeclaration(__sfc));
    ast = ((_b = (_a = options === null || options === void 0 ? void 0 : options.astTransforms) === null || _a === void 0 ? void 0 : _a.post) === null || _b === void 0 ? void 0 : _b.call(_a, ast, sfc)) || ast;
    return {
        ast,
        code: generate(ast).code,
    };
}

function transformSfcRefSugar(sfc, options) {
    const importedHelpers = new Set();
    for (const script of [sfc.script, sfc.scriptSetup]) {
        if (reactivityTransform.shouldTransform(script.content)) {
            const s = new MagicString__default["default"](script.content);
            const { importedHelpers: imports } = reactivityTransform.transformAST(script.ast, s);
            Array.from(imports).forEach(helper => importedHelpers.add(helper));
            script.content = s.toString();
            script.ast = parser.parse(script.content, sfc.parserOptions).program;
        }
    }
    if (importedHelpers.size) {
        sfc.extraDeclarations = [
            t.importDeclaration(Array.from(importedHelpers).map(i => t.importSpecifier(t.identifier(`_${i}`), t.identifier(i))), t.stringLiteral(options.importHelpersFrom)),
        ];
    }
}

function resolveOptions(options = {}) {
    return Object.assign({}, {
        sourceMap: true,
        reactivityTransform: false,
        importHelpersFrom: '@vue/composition-api',
        astTransforms: {},
    }, options);
}

const scriptSetupRE = /<script\s(.*\s)?setup(\s.*)?>/;
function shouldTransform(code, id, options) {
    // avoid transforming twice
    if (code.includes('export default __sfc_main'))
        return false;
    return ((options === null || options === void 0 ? void 0 : options.reactivityTransform) && reactivityTransform.shouldTransform(code)) || scriptSetupRE.test(code);
}
function transform(input, id, options) {
    if (!shouldTransform(input, id, options))
        return null;
    const resolved = resolveOptions(options);
    if (id.endsWith('.vue') || id.includes('.vue?vue'))
        return transformVue(input, id, resolved);
    else
        return transformNonVue(input, id, resolved);
}
function transformNonVue(input, id, options) {
    if (options.reactivityTransform && reactivityTransform.shouldTransform(input)) {
        return reactivityTransform.transform(input, {
            filename: id,
            sourceMap: options.sourceMap,
            importHelpersFrom: options.importHelpersFrom,
        });
    }
    return null;
}
function transformVue(input, id, options) {
    const s = new MagicString__default["default"](input);
    const sfc = parseSFC(input, id);
    if (options.reactivityTransform)
        transformSfcRefSugar(sfc, options);
    const { code } = transformScriptSetup(sfc, options);
    const attributes = Object.assign(Object.assign({}, sfc.script.attrs), sfc.scriptSetup.attrs);
    delete attributes.setup;
    const attr = Object.entries(attributes)
        .map(([key, value]) => value ? `${key}="${value}"` : key)
        .join(' ');
    if (code) {
        const block = `<script ${attr}>\n${code}\n</script>`;
        s.remove(sfc.script.start, sfc.script.end);
        if (sfc.scriptSetup.start !== sfc.scriptSetup.end) {
            s.overwrite(sfc.scriptSetup.start, sfc.scriptSetup.end, block);
        }
        else {
            s.prependLeft(0, `${block}\n`);
        }
    }
    return {
        code: s.toString(),
        map: options.sourceMap
            ? s.generateMap({
                source: id,
                includeContent: true,
            })
            : null,
    };
}

const unplugin = unplugin$1.createUnplugin((options = {}) => {
    const filter = pluginutils.createFilter(options.include || (options.reactivityTransform ? [/\.vue$/, /\.vue\?vue/, /\.[jt]sx?$/] : [/\.vue$/, /\.vue\?vue/]), options.exclude || [/node_modules/, /\.git/, /\.nuxt/]);
    return {
        name: 'unplugin-vue2-script-setup',
        enforce: 'pre',
        transformInclude(id) {
            return filter(id);
        },
        transform(code, id) {
            try {
                return transform(code, id, options);
            }
            catch (e) {
                this.error(e);
            }
        },
    };
});

exports["default"] = unplugin;
exports.shouldTransform = shouldTransform;
exports.transform = transform;
exports.transformScriptSetup = transformScriptSetup;
exports.unplugin = unplugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
